name: Build
run-name: Build v${{ inputs.version || vars.CURRENT_VERSION }}

on:
  workflow_dispatch:
    inputs:
      use_self_hosted_runners:
        description: "Use Self-Hosted Runners"
        required: true
        default: true
        type: boolean

      retention_days_artifacts:
        description: "Retention Days for Artifacts"
        required: false
        default: 1
        type: number

      version:
        description: "Version number (leave empty for auto)"
        required: false
        default: ""
        type: string
      
      prerelease:
        description: "Is this a prerelease version?"
        required: false
        default: true
        type: boolean

      notarize_mac_undle:
        description: "Notarize macOS bundle"
        required: false
        default: false
        type: boolean

env:
  VERSION: ${{ inputs.version || vars.CURRENT_VERSION }}
  RETENTION_DAYS_ARTIFACTS: ${{ inputs.retention_days_artifacts || 1 }}

jobs:
  set-version:
    name: Increment Version
    runs-on: ${{ fromJson(inputs.use_self_hosted_runners) && fromJson('["self-hosted","Linux"]') || fromJson('["ubuntu-latest"]') }}
    permissions:
      contents: read
      actions: write
    outputs:
      version: ${{ steps.setver.outputs.version }}
    env:
      GH_TOKEN: ${{ secrets.GH_VARIABLES_PAT }}
    steps:
      - name: Checkout
        uses: actions/checkout@v6
        with:
          clean: true
          fetch-depth: 0

      - name: Set Next Version
        id: setver
        shell: pwsh
        run: |
          # Use supplied version if provided, otherwise fall back to the repo variable
          Write-Host "Using source version: $env:VERSION"
          $CurrentVersion = [System.Version]::Parse("$env:VERSION")
          Write-Host "Resolved current version: $CurrentVersion"
          $NextVersion = "$($CurrentVersion.Major).$($CurrentVersion.Minor).$($CurrentVersion.Build + 1).0"
          Write-Host "Next version will be: $NextVersion"
          # Persist next version to GH Variables for future runs
          if ($IsLinux) {
            /usr/bin/gh variable set CURRENT_VERSION --body $NextVersion
          }
          elseif ($IsMacOS) {
            /opt/homebrew/bin/gh variable set CURRENT_VERSION --body $NextVersion
          }
          else {
            gh variable set CURRENT_VERSION --body $NextVersion
          }
          # Expose the next version as a step output for the job
          echo "version=$NextVersion" >> $GITHUB_OUTPUT

  run-tests:
    name: Run Tests
    runs-on: ${{ fromJson(inputs.use_self_hosted_runners) && fromJson('["self-hosted","Linux"]') || fromJson('["ubuntu-latest"]') }}
    needs: set-version

    steps:
      - name: Checkout
        uses: actions/checkout@v6
        with:
          clean: true
          fetch-depth: 0

      - name: Setup .NET
        uses: ./.github/actions/setup-dotnet

      - name: Run Tests
        run: |
          dotnet test -c Release

  build-nuget-packages:
    name: Build NuGet Packages
    runs-on: ${{ fromJson(inputs.use_self_hosted_runners) && fromJson('["self-hosted","Linux"]') || fromJson('["ubuntu-latest"]') }}
    needs: set-version

    steps:
      - name: Checkout
        uses: actions/checkout@v6
        with:
          clean: true
          fetch-depth: 0

      - name: Setup .NET
        uses: ./.github/actions/setup-dotnet

      - name: Build and Upload ControlR.ApiClient
        uses: ./.github/actions/build-upload-nuget
        with:
          project-path: ControlR.ApiClient/ControlR.ApiClient.csproj
          version: ${{ env.VERSION }}
          artifact-name: ApiClientNuGet
          retention-days: ${{ env.RETENTION_DAYS_ARTIFACTS }}
          prerelease: ${{ inputs.prerelease }}

      - name: Build and Upload ControlR.Libraries.DataRedaction
        uses: ./.github/actions/build-upload-nuget
        with:
          project-path: Libraries/ControlR.Libraries.DataRedaction/ControlR.Libraries.DataRedaction.csproj
          version: ${{ env.VERSION }}
          artifact-name: DataRedactionNuGet
          retention-days: ${{ env.RETENTION_DAYS_ARTIFACTS }}
          prerelease: ${{ inputs.prerelease }}

  build-mac-binaries:
    name: Apple Build (${{ matrix.arch }})
    runs-on: ${{ fromJson(inputs.use_self_hosted_runners) && fromJson('["self-hosted","macOS"]') || fromJson('["macos-latest"]') }}
    needs: set-version
    strategy:
      matrix:
        arch: [osx-arm64, osx-x64]

    steps:
      - name: Checkout
        uses: actions/checkout@v6
        with:
          clean: true
          fetch-depth: 0

      - name: Setup .NET
        uses: ./.github/actions/setup-dotnet

      - name: Setup Code Signing Keychain
        env:
          APPLE_P12_BASE64: ${{ secrets.APPLE_P12_BASE64 }}
          APPLE_P12_PASSWORD: ${{ secrets.APPLE_P12_PASSWORD }}
          APPLE_DEVELOPER_ID: ${{ secrets.APPLE_DEVELOPER_ID }}
        shell: bash
        run: |
          # Create temporary keychain
          KEYCHAIN_PATH="$RUNNER_TEMP/build.keychain"
          KEYCHAIN_PASSWORD=$(openssl rand -base64 32)
          
          echo "Creating temporary keychain..."
          security create-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"
          echo "Configuring keychain settings..."
          security set-keychain-settings -lut 21600 "$KEYCHAIN_PATH"
          echo "Unlocking keychain..."
          security unlock-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"

          ORIGINAL_KEYCHAINS=$(security list-keychains -d user | xargs)
          echo "ORIGINAL_KEYCHAINS=$ORIGINAL_KEYCHAINS" >> "$GITHUB_ENV"
          echo "Adding temporary keychain to search list..."
          security list-keychains -d user -s "$KEYCHAIN_PATH" $ORIGINAL_KEYCHAINS
          
          echo "Decoding and importing certificate..."
          P12_PATH="$RUNNER_TEMP/certificate.p12"
          echo "$APPLE_P12_BASE64" | base64 --decode > "$P12_PATH"
          
          security import "$P12_PATH" \
            -k "$KEYCHAIN_PATH" \
            -P "$APPLE_P12_PASSWORD" \
            -T /usr/bin/codesign \
            -T /usr/bin/productsign
          
          echo "Setting partition list..."
          security set-key-partition-list -S apple-tool:,apple:,codesign: -s -k "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"
          
          echo "Verifying certificate import..."
          security find-identity -v -p codesigning "$KEYCHAIN_PATH"

          # Extract the unique SHA-1 hash for the identity in the temporary keychain
          IDENTITY_HASH=$(security find-identity -v -p codesigning "$KEYCHAIN_PATH" | grep "$APPLE_DEVELOPER_ID" | head -n 1 | awk '{print $2}')
          if [ -z "$IDENTITY_HASH" ]; then
            echo "ERROR: No signing identity found for APPLE_DEVELOPER_ID in temporary keychain."
            exit 1
          fi
          echo "IDENTITY_HASH=$IDENTITY_HASH" >> "$GITHUB_ENV"

      - name: Publish DesktopClient + Agent (${{ matrix.arch }})
        run: |
          PUBLISH_DIR="./ControlR.DesktopClient/bin/publish/"

          # Clean Resources folder
          if [ -d "./ControlR.Agent.Common/Resources" ]; then
            find "./ControlR.Agent.Common/Resources" -maxdepth 1 -type f -name '*.zip' -exec rm -f -- {} +
          fi

          echo "Publishing version $VERSION for macOS ${{ matrix.arch }}..."
          # Build DesktopClient
          dotnet publish "./ControlR.DesktopClient/" \
            -c Release \
            -r ${{ matrix.arch }} \
            --self-contained \
            -p:Version=$VERSION \
            -p:FileVersion=$VERSION \
            -o "$PUBLISH_DIR/${{ matrix.arch }}/"

          # verify publish output exists (fail-fast with diagnostics)
          if [ ! -f "$PUBLISH_DIR/${{ matrix.arch }}/ControlR.DesktopClient" ]; then
            ls -la "$PUBLISH_DIR/${{ matrix.arch }}/" || true
            echo "ERROR: DesktopClient publish output missing: $PUBLISH_DIR/${{ matrix.arch }}/ControlR.DesktopClient"
            exit 1
          fi

          echo "Code signing DesktopClient for macOS ${{ matrix.arch }}..."
          codesign \
            --force \
            --deep \
            --options runtime \
            --timestamp \
            --entitlements "./.build/Mac/ControlR.entitlements" \
            --keychain "$RUNNER_TEMP/build.keychain" \
            --sign "$IDENTITY_HASH" \
            "$PUBLISH_DIR/${{ matrix.arch }}/ControlR.DesktopClient"

          echo "Creating Mac app bundle for macOS ${{ matrix.arch }}..."
          pwsh "./.build/Mac/CreateMacApp.ps1" -OutputDir "$PUBLISH_DIR/${{ matrix.arch }}/"
          ditto -c -k --sequesterRsrc "$PUBLISH_DIR/${{ matrix.arch }}/" "$PUBLISH_DIR/${{ matrix.arch }}/ControlR.app.zip"

          # Copy DesktopClient ZIP to Agent Resources
          echo "Copying DesktopClient ZIP to Agent Resources..."
          mkdir -p "./ControlR.Agent.Common/Resources"
          cp "$PUBLISH_DIR/${{ matrix.arch }}/ControlR.app.zip" "./ControlR.Agent.Common/Resources/ControlR.app.zip"

          # Build Agent
          echo "Publishing Agent for macOS ${{ matrix.arch }}..."
          dotnet publish "./ControlR.Agent/" \
            -c Release \
            -r ${{ matrix.arch }} \
            --self-contained \
            -p:PublishSingleFile=true \
            -p:UseAppHost=true \
            -p:Version=$VERSION \
            -p:FileVersion=$VERSION \
            -p:IncludeAllContentForSelfExtract=true \
            -p:EnableCompressionInSingleFile=true \
            -p:IncludeAppSettingsInSingleFile=true \
            -o "./ControlR.Agent/bin/publish/${{ matrix.arch }}/"

          # verify publish output exists (fail-fast with diagnostics)
          if [ ! -f "./ControlR.Agent/bin/publish/${{ matrix.arch }}/ControlR.Agent" ]; then
            ls -la "./ControlR.Agent/bin/publish/${{ matrix.arch }}/" || true
            echo "ERROR: Agent publish output missing: ./ControlR.Agent/bin/publish/${{ matrix.arch }}/ControlR.Agent"
            exit 1
          fi

          echo "Code signing Agent for macOS ${{ matrix.arch }}..."
          codesign \
            --force \
            --deep \
            --options runtime \
            --timestamp \
            --entitlements "./.build/Mac/ControlR.entitlements" \
            --keychain "$RUNNER_TEMP/build.keychain" \
            --sign "$IDENTITY_HASH" \
            "./ControlR.Agent/bin/publish/${{ matrix.arch }}/ControlR.Agent"

      - name: Upload Agent (${{ matrix.arch }})
        uses: actions/upload-artifact@v6
        with:
          name: Agent-macOS-${{ matrix.arch == 'osx-arm64' && 'ARM64' || 'x64' }}
          path: ControlR.Agent/bin/publish/${{ matrix.arch }}/ControlR.Agent
          retention-days: ${{ env.RETENTION_DAYS_ARTIFACTS }}

      - name: Cleanup Keychain
        if: always()
        run: |
          KEYCHAIN_PATH="$RUNNER_TEMP/build.keychain"
          if [ -n "$ORIGINAL_KEYCHAINS" ]; then
            echo "Restoring original keychain search list..."
            security list-keychains -d user -s $ORIGINAL_KEYCHAINS
          fi
          if [ -f "$KEYCHAIN_PATH" ]; then
            echo "Removing temporary keychain..."
            security delete-keychain "$KEYCHAIN_PATH" 2>/dev/null || true
          fi

  build-windows-binaries:
    name: Windows Build (${{ matrix.arch }})
    # When using self-hosted Windows runners, require both the self-hosted label and OS label.
    runs-on: ${{ fromJson(inputs.use_self_hosted_runners) && fromJson('["self-hosted","Windows"]') || fromJson('["windows-latest"]') }}
    environment: secure-signing
    needs: set-version
    permissions:
      id-token: write
      contents: read
    strategy:
      matrix:
        arch: [win-x86, win-x64]

    steps:
      - name: Checkout
        uses: actions/checkout@v6
        with:
          clean: true
          fetch-depth: 0
          submodules: recursive

      - name: Setup .NET
        uses: ./.github/actions/setup-dotnet

      # ===== Azure Login with OIDC =====
      - name: Azure Login
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      # ===== Install AzureSignTool =====
      - name: Install AzureSignTool
        shell: pwsh
        run: |
          dotnet tool install --global AzureSignTool

      # ===== Build Windows =====
      - name: Build DesktopClient (${{ matrix.arch }})
        shell: pwsh
        run: |
          # Clean Resources folder
          Remove-Item -Path "ControlR.Agent.Common\Resources\*.zip" -Force -ErrorAction SilentlyContinue

          # Build DesktopClient
          dotnet publish ControlR.DesktopClient\ -c Release -r ${{ matrix.arch }} --self-contained -o ControlR.DesktopClient\bin\publish\${{ matrix.arch }}\ -p:Version=$env:VERSION -p:FileVersion=$env:VERSION

      - name: Sign DesktopClient (${{ matrix.arch }})
        shell: pwsh
        run: |
          dnx azuresigntool --yes sign `
            --du="${{ vars.SIGNING_DESCRIPTION_URL }}" `
            --fd=sha256 `
            --kvu="${{ secrets.AZURE_KEY_VAULT_URI }}" `
            --kvc="${{ secrets.AZURE_KEY_VAULT_CERTIFICATE_NAME }}" `
            --kvm `
            --tr=http://timestamp.digicert.com `
            --td=sha256 `
            --skip-signed `
            "${{ github.workspace }}\ControlR.DesktopClient\bin\publish\${{ matrix.arch }}\*.exe " `
            "${{ github.workspace }}\ControlR.DesktopClient\bin\publish\${{ matrix.arch }}\*.dll"

      - name: Package and Prepare DesktopClient (${{ matrix.arch }})
        shell: pwsh
        run: |
          # Create staging directory
          New-Item -Path ".build\staging-desktop\${{ matrix.arch }}" -ItemType Directory -Force | Out-Null

          # Create ZIP
          Compress-Archive -Path "ControlR.DesktopClient\bin\publish\${{ matrix.arch }}\*" -DestinationPath ".build\staging-desktop\${{ matrix.arch }}\ControlR.DesktopClient.zip" -Force

          # Copy to Agent Resources
          New-Item -Path "ControlR.Agent.Common\Resources" -ItemType Directory -Force | Out-Null
          Copy-Item ".build\staging-desktop\${{ matrix.arch }}\ControlR.DesktopClient.zip" "ControlR.Agent.Common\Resources\ControlR.DesktopClient.zip" -Force

      - name: Build Agent (${{ matrix.arch }})
        shell: pwsh
        run: |
          New-Item -Path "ControlR.Web.Server\wwwroot\downloads\${{ matrix.arch }}" -ItemType Directory -Force | Out-Null
          dotnet publish ControlR.Agent\ -c Release -r ${{ matrix.arch }} -o ControlR.Web.Server\wwwroot\downloads\${{ matrix.arch }}\ -p:PublishSingleFile=true -p:UseAppHost=true -p:Version=$env:VERSION -p:FileVersion=$env:VERSION -p:IncludeAllContentForSelfExtract=true -p:EnableCompressionInSingleFile=true -p:IncludeAppSettingsInSingleFile=true

      - name: Sign Agent (${{ matrix.arch }})
        shell: pwsh
        run: |
          dnx azuresigntool --yes sign `
            --du="${{ vars.SIGNING_DESCRIPTION_URL }}" `
            --fd=sha256 `
            --kvu="${{ secrets.AZURE_KEY_VAULT_URI }}" `
            --kvc="${{ secrets.AZURE_KEY_VAULT_CERTIFICATE_NAME }}" `
            --kvm `
            --tr=http://timestamp.digicert.com `
            --td=sha256 `
            --skip-signed `
            "${{ github.workspace }}\ControlR.Web.Server\wwwroot\downloads\${{ matrix.arch }}\*.exe " `
            "${{ github.workspace }}\ControlR.Web.Server\wwwroot\downloads\${{ matrix.arch }}\*.dll"

      - name: Upload Agent (${{ matrix.arch }})
        uses: actions/upload-artifact@v6
        with:
          name: Agent-${{ matrix.arch }}
          path: ControlR.Web.Server\wwwroot\downloads\${{ matrix.arch }}\ControlR.Agent.exe
          retention-days: ${{ env.RETENTION_DAYS_ARTIFACTS }}

  build-linux-binaries:
    name: Linux Build
    runs-on: ${{ fromJson(inputs.use_self_hosted_runners) && fromJson('["self-hosted","Linux"]') || fromJson('["ubuntu-latest"]') }}
    needs: [set-version]

    steps:
      - name: Checkout
        uses: actions/checkout@v6
        with:
          clean: true
          fetch-depth: 0
          submodules: recursive

      - name: Setup .NET
        uses: ./.github/actions/setup-dotnet

      - name: Build DesktopClient (linux-x64)
        run: |
          # Clean Resources folder
          rm -f "./ControlR.Agent.Common/Resources/*.zip"

          # Build DesktopClient
          dotnet publish ./ControlR.DesktopClient/ -c Release -r linux-x64 --self-contained -o ./ControlR.DesktopClient/bin/publish/linux-x64/ -p:Version=$VERSION -p:FileVersion=$VERSION

          # Create staging directory
          mkdir -p ".build/staging-desktop/linux-x64"

          # Create ZIP
          cd ./ControlR.DesktopClient/bin/publish/linux-x64/
          zip -r ../../../../.build/staging-desktop/linux-x64/ControlR.DesktopClient.zip .
          cd ../../../..

          # Copy to Agent Resources
          mkdir -p "./ControlR.Agent.Common/Resources"
          cp ".build/staging-desktop/linux-x64/ControlR.DesktopClient.zip" "./ControlR.Agent.Common/Resources/ControlR.DesktopClient.zip"

      - name: Build Agent (linux-x64)
        run: |
          mkdir -p "./ControlR.Web.Server/wwwroot/downloads/linux-x64"
          dotnet publish ./ControlR.Agent/ -c Release -r linux-x64 -o ./ControlR.Web.Server/wwwroot/downloads/linux-x64/ -p:PublishSingleFile=true -p:UseAppHost=true -p:Version=$VERSION -p:FileVersion=$VERSION -p:IncludeAllContentForSelfExtract=true -p:EnableCompressionInSingleFile=true -p:IncludeAppSettingsInSingleFile=true

      - name: Upload Agent (linux-x64)
        uses: actions/upload-artifact@v6
        with:
          name: Agent-linux-x64
          path: ControlR.Web.Server/wwwroot/downloads/linux-x64/ControlR.Agent
          retention-days: ${{ env.RETENTION_DAYS_ARTIFACTS }}

  build-web-server:
    name: Build Web Server
    runs-on: ${{ fromJson(inputs.use_self_hosted_runners) && fromJson('["self-hosted","fast"]') || fromJson('["ubuntu-latest"]') }}
    needs:
      [
        build-windows-binaries,
        build-linux-binaries,
        build-mac-binaries,
        run-tests,
      ]

    steps:
      - name: Checkout
        uses: actions/checkout@v6
        with:
          clean: true
          fetch-depth: 0
          submodules: recursive

      - name: Setup .NET
        uses: ./.github/actions/setup-dotnet

      - name: Download Agent (win-x86)
        uses: actions/download-artifact@v7
        with:
          name: Agent-win-x86
          path: ControlR.Web.Server/wwwroot/downloads/win-x86/

      - name: Download Agent (win-x64)
        uses: actions/download-artifact@v7
        with:
          name: Agent-win-x64
          path: ControlR.Web.Server/wwwroot/downloads/win-x64/

      - name: Download Agent (linux-x64)
        uses: actions/download-artifact@v7
        with:
          name: Agent-linux-x64
          path: ControlR.Web.Server/wwwroot/downloads/linux-x64/

      - name: Download Agent (macOS ARM64)
        uses: actions/download-artifact@v7
        with:
          name: Agent-macOS-ARM64
          path: ControlR.Web.Server/wwwroot/downloads/osx-arm64/

      - name: Download Agent (macOS x64)
        uses: actions/download-artifact@v7
        with:
          name: Agent-macOS-x64
          path: ControlR.Web.Server/wwwroot/downloads/osx-x64/

      - name: Create Version.txt
        shell: pwsh
        run: |
          Set-Content -Path "ControlR.Web.Server/wwwroot/downloads/Version.txt" -Value $env:VERSION -Force -Encoding UTF8

      - name: Build Web Server
        shell: pwsh
        run: |
          New-Item -Path "ControlR.Web.Server/bin/publish" -ItemType Directory -Force | Out-Null
          dotnet publish ControlR.Web.Server/ -p:ExcludeApp_Data=true --runtime linux-x64 --configuration Release -p:Version=$env:VERSION -p:FileVersion=$env:VERSION --output ControlR.Web.Server/bin/publish --self-contained true

      - name: Verify Agent Binaries
        shell: pwsh
        run: |
          $TestPaths = @(
            "ControlR.Web.Server/bin/publish/wwwroot/downloads/Version.txt",
            "ControlR.Web.Server/bin/publish/wwwroot/downloads/win-x86/ControlR.Agent.exe",
            "ControlR.Web.Server/bin/publish/wwwroot/downloads/win-x64/ControlR.Agent.exe",
            "ControlR.Web.Server/bin/publish/wwwroot/downloads/linux-x64/ControlR.Agent",
            "ControlR.Web.Server/bin/publish/wwwroot/downloads/osx-arm64/ControlR.Agent",
            "ControlR.Web.Server/bin/publish/wwwroot/downloads/osx-x64/ControlR.Agent",
            "ControlR.Web.Server/bin/publish/novnc/vnc.html"
          )
          foreach ($TestPath in $TestPaths) {
            if (!(Test-Path $TestPath)) {
              Write-Error "$TestPath not found."
              exit 1
            }
          }

      - name: Upload Server
        uses: actions/upload-artifact@v6
        with:
          name: Server
          path: ControlR.Web.Server/bin/publish
          retention-days: ${{ env.RETENTION_DAYS_ARTIFACTS }}

      - name: Upload docker-compose
        uses: actions/upload-artifact@v6
        with:
          name: DockerCompose
          path: docker-compose/docker-compose.yml
          retention-days: ${{ env.RETENTION_DAYS_ARTIFACTS }}
